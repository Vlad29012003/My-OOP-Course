class User:
    args = {
        'version':1,
        'flags': 2
        }
    
    def __init__(self):
        self.__dict__ = self.args


class TreadData:
    __common_attr = {
        'name':"tread_1",
        "data":{},
        "id":1 , 
    }

    def __init__(self):
        self.__dict__ = TreadData.__common_attr


# При создании экземпляра у нас вызывается метод __init__, тем самым мы обращаемся к __dict__,
# который содержит все атрибуты объекта. Мы присваиваем в него ссылку на __common_attrs, тем самым все
# экземпляры будут содержать одинаковый объект в памяти и будут ссылаться на одинаковый адрес. Поэтому
# при изменении любого экземпляра это также отразится и на всех остальных экземплярах.

# Аналогично это работает и с обычными списками. Попробуйте сделать следующее:

a = [1, 2, 3]
b = a
b.append(4)
print(a) # Output: [1, 2, 3, 4]

# В итоге после изменения переменной b, отредактируется также и переменная a. Это происходит, потому
# что мы присваиваем ссылку на объект, а не его данные.



# Моноcостояние — это шаблон проектирования, в котором все экземпляры класса имеют одно и то же
# внутреннее состояние. Можно создать несколько экземпляров класса, но все они будут ссылаться на одно и
# то же общее состояние.



# Шаблон моносостояния достигается за счет использования атрибутов класса для хранения общего состояния
# вместо атрибута экземпляра. Атрибуты на уровне класса, создаются один раз при определении класса и
# являются общими для всех экземпляров:


class Monostate:
    __shared_state = {"x": 0}

    def __init__(self):
        self.__dict__ = self.__shared_state

    def increment(self):
        self.x += 1

a = Monostate()
b = Monostate()

a.increment()
print(b.x) # Output: 1


# Моносостояния могут быть полезны в ситуациях, когда вы хотите, чтобы все экземпляры класса имели
# доступ к одному и тому же состоянию, и чтобы изменения, внесенные в состояние одним экземпляром, были
# отражены во всех других экземплярах.



# Однако моносостояния также могут быть проблематичны, поскольку они могут привести к неожиданному
# поведению и затруднить анализ состояния вашей программы. Если вы используете моносостояние, важно быть
# осторожным с тем, как вы изменяете общее состояние, и также нужно четко документировать поведение
# вашего класса.


# Фишки с Моносостоянием

# Хранение общих атрибутов во всех экземплярах класса



class Monostate:
    _state = {}

    # Привязываем все объекты к общему состоянию _state
    def __new__(cls, *args, **kwargs):
        obj = super().__new__(cls)
        obj.__dict__ = cls._state
        return obj

    def __init__(self, x):
        self.x = x

a = Monostate(10)
b = Monostate(20)
print(a.x)  # Output: 20
print(b.x)  # Output: 20

a.y = 10
print(b.y)  # Output: 10



# Это достаточно опасный код, так как мы неявно присваиваем новые атрибуты во все экземпляры, поэтому
# такой код может вызвать огромное количество багов. Но он очень хорошо отражает принцип общего
# состояния.