# Вопрос: Есть ли возможность обратиться к классу напрямую, без создания экземпляра, и
# вызвать метод, который использует @staticmethod?
# Варианты ответа:

# а) да
# б) нет


# Ответ а

class MyClass:
    @staticmethod
    def my_method():
        print("Hello from static method")

MyClass.my_method() 



# Задание 1.2
# Вопрос: Позволяет ли slots ускорить выполнение программы?
# Варианты ответа:
# а) Да
# б) Нет

# Ответ а)


# Использование __slots__ в Python может ускорить выполнение программы. Это происходит потому, что __slots__ ограничивает атрибуты, которые экземпляры класса могут иметь, 
# и устраняет использование словаря (__dict__) для хранения атрибутов, что снижает накладные расходы на память и ускоряет доступ к атрибутам.


# Вопрос: Что запускается первым при создании экземпляра?
#Варианты ответа:
# а) __new__
# б) __init__
# в) __mul__

# Ответ а 



# Метод __new__ запускается первым при создании экземпляра класса. Он отвечает за создание нового объекта и возвращает его. 
# После того как объект создан, вызывается метод __init__, который инициализирует объект (например, устанавливает его атрибуты).



# Вопрос: Возможно ли с помощью __new__ создать экземпляр класса?
# Варианты ответа:
# а) Да
# б) Нет


# Метод __new__ предназначен именно для создания нового экземпляра класса. 
# Он отвечает за создание и возвращение нового объекта. Вы можете переопределить __new__, 
# чтобы изменить процесс создания экземпляра, например, возвращать экземпляр другого класса или даже предотвращать создание экземпляра.

class MyClass:
    def __new__(cls):
        instance = super().__new__(cls)
        return instance

    def __init__(self):
        print("Instance initialized")

obj = MyClass()



# Вопрос: Возможно ли создать экземпляр из @classmethod
# Варианты ответа:
# а) Нет, с помощью @classmethod мы можем только создавать методы на уровне класса
# б) Да, так как он принимает объект класса

# Ответ б 

# С помощью @classmethod действительно можно создать экземпляр класса, потому что метод, помеченный как @classmethod, принимает первым аргументом сам класс (обычно обозначаемый как cls).
#  Вы можете использовать этот аргумент для создания нового экземпляра.


class MyClass:
    def __init__(self, value):
        self.value = value

    @classmethod
    def create_instance(cls, value):
        return cls(value)

obj = MyClass.create_instance(10)
print(obj.value)  # Выведет 10



class Test:
    version = 1

    def __init__(self , name):
        self.name = name

    @classmethod
    def rewrite(cls):
        cls.version = 2

a = Test(1)
b = Test(2)

a.rewrite()

print(b.version)

# б) Это возможно, в данном случае выводится 2



# Вопрос: Можно ли хранить важные данные в приватных атрибутах? Вроде логинов,
# паролей, API-токенов
# Варианты ответа:
# а) Да
# б) Нет

# ответ нет 

# Хотя приватные атрибуты в Python (обозначаемые как __attribute) делают доступ к данным сложнее,
# они не обеспечивают полной безопасности. Приватные атрибуты всё ещё могут быть доступны через обходные пути, такие как использование именования класса.



# Вопрос: Предоставляет ли инкапсуляция полное сокрытие данных, которые невозможно
# прочитать?
# Варианты ответа:
# а) Да
# б) Нет

# ответ б 

# Инкапсуляция в Python не обеспечивает полного сокрытия данных.
# Даже если атрибуты помечены как приватные (с использованием двойного подчёркивания, например, __attribute), их всё ещё можно прочитать с помощью определённых методов,
#  таких как обход через манипуляции с именами.


# Вопрос: Инкапсуляция - это ...
# Варианты ответа:
# а) Технология, которая позволяет переопределять атрибуты
# б) Технология для защиты и шифрования данных
# в) Сокрытие данных

# ответ в

# Инкапсуляция — это концепция в объектно-ориентированном программировании, которая относится к сокрытию данных и деталей реализации внутри класса.
# Она позволяет управлять доступом к данным, защищая внутреннее состояние объекта от внешнего вмешательства и нежелательных изменений.



# Вопрос: Почему при изменении любого экземпляра все данные редактируются глобально?
# Варианты ответа:
# а) Так как при создании экземпляра данные изначально ссылаются на один адрес
# б) Потому что мы используем __init__
# в) Так как они все ссылаются на одинаковую ячейку в памяти и содержат прямую ссылку на
# объект

# ответ в 

# Если несколько экземпляров класса ссылаются на один и тот же объект или изменяемую структуру данных (например, список или словарь),
# изменение одного экземпляра может повлиять на другие, потому что все они ссылаются на одну и ту же область памяти.



# Вопрос: Что позволяет сделать декоратор @singledispatch?
# Варианты ответа:
# а) Реализовать разное поведение того же метода
# б) Использовать перегрузку операторов

# Ответ а 

# Декоратор @singledispatch из модуля functools позволяет реализовать одноимённый метод, который может по-разному обрабатывать аргументы в зависимости от их типа. 
# Это позволяет создавать функции с разным поведением в зависимости от типа входного аргумента, что напоминает перегрузку функций в других языках программирования.
